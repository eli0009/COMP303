# Object state

## Abstract state

An abstract state is a state that impact how an object would be used. For example appending to a linked list when it is empty vs when it has more than 1 element

## Optional type

Use `Optional.empty()` instead of `null` to help avoid nullpointer exceptions.
```java
// create null in optional
Optional<String> nullStr = Optional.empty();
// turn object into optional, works with null value
Optional<String> str = Optional.ofNullable("Hello");
// if-else
nullStr.ifPresentOrElse(t -> System.out.println(t), () -> System.out.println("String is empty"));
System.out.println(nullStr.isEmpty()); // True
System.out.println(str.isPresent()); // True
// Get the value, doesn't work with empty Optional
System.out.println(str.get());
```

## NULL OBJECT design pattern

Goal: avoid `null` and `Optional`, but still avoid nullpointer exceptions.

Create an implementation of an interface that represents a null class instead of directly passing `null` so that the code doesn't break when null isn't checked.


## FLYWEIGHT design pattern

Goal: Avoid redundancy when storing data

Create an array that contains the values, then newly created object simply need to keep track of the index of the value, saving memory. 4 steps to realize this:
1. private constructor
2. static initializing fields that creates the flyweight objects
3. static flyweight store (ex: array) that stores all the flyweight objects
4. static access method that returns the flyweigth objects according to a key
```java
class Scarlet {
    private String name;
    // static flyweight store
    private static final Scarlet[] s = new Scarlet[2];

    // private constructor
    private Scarlet(String name) {
        this.name = name + " Scarlet";
    }

    // static initializing field
    static {
        s[0] = new Scarlet("Flandre");
        s[1] = new Scarlet("Remilia");
    }

    // the key
    enum AGE {
        YOUNG, OLD
    }

    // static access method
    public static Scarlet get(AGE a) {
        assert a != null;
        return s[a.ordinal()];
    }

    public String toString() {
        return name;
    }
}

public class Main {

    public static void main(String[] args) {

        Scarlet flan = Scarlet.get(Scarlet.AGE.YOUNG);
        System.out.println(flan);
    }
}
```

## SINGLETON design pattern

Goal: ensure only 1 instance of class (ex: database access, aggregation of states)

This is similar to flyweight, but in this case we only want 1 instance, so no key, and the store is a variable that points to the instance. 3 steps to realize this:
1. private constructor
2. variable that points to the instance
3. static access method
```java
public class Main {

    public static void main(String[] args) {
        BasicSingleton bs1 = BasicSingleton.getInstance();
        BasicSingleton bs2 = BasicSingleton.getInstance();
        System.out.println(bs1 == bs2); // true, they are the same instance
    }
}

class BasicSingleton {
    private int value;

    // private constructor
    private BasicSingleton() {
        this.value = 0;
    }

    // variable that points to the instance
    private static final BasicSingleton instance = new BasicSingleton();

    // static access method
    public static BasicSingleton getInstance() {
        return instance;
    }

    public int getValue() {
        return this.value;
    }

    public void setValue(int value) {
        this.value = value;
    }

}
```