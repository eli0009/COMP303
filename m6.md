# Composition

## COMPOSITE design pattern

Composite allows us to treat both single objects and composite objects uniformly via inheritance (through method calls). To use composite:
1. Create interface/parent class
2. Create new single element class that implements the interface
3. Create composite element class that implements the interface

The composite class has:
- A List<> containing the single elements
- A method for adding elements to it
- Same methods as the single elements (from implementing interface)
- Methods that delegate calls to its single elements

See [Composite.java](code/Composite.java)

## DECORATOR design pattern

Decorator allows adding additional functionality to class without modifying or subclassing it. To use decorator:

1. Create interface
2. Create class that implements interface
3. Create decorator class that implements interface and has the class created in step 2 as field
   
Characteristic of decorator class:
- Decorated class as a field (often received from constructor)
- Same methods as the decorated elements (from implementing interface)
- Method makes calls to decorated elements

See [Decorator.java](code/Decorator.java)

## PROTOTYPE design pattern

Prototype is a template object that can be used as a shortcut to create new objects with similar attributes.
You can either implement Cloneable (not recommended) or create your own copy() method

### Note on using Cloneable
- Shallow copy (immutable fields): simply return `super.clone()` in a try-catch block
- Deep copy (mutable fields): create a new object and copy each field manually, or get clone from `super.clone()` and copy each mutable field manually

See [Prototype.java](code/Prototype.java)


