# Types and Interfaces

## Polymorphism

Interface allows any objects with the required methods to use a piece of code. Implementing an interface makes the class a subtype of the interface.

The class Bird is a subtype of Fly:
```java
class Bird implements Fly {

}
```

Using interface enables polymorphism because now we can assign a reference to `Bird` to a `Fly` variable
```java
Fly fly = new Bird();
```

A practical example with arraylist and linkedlist. Both classes are implementation of the `List` interface.
```java
List<Integer> list = new ArrayList<>();
List<Integer> list = new LinkedList<>();
```

## Iterator and Iterable

How to use iterator:
```java
import java.util.Iterator;

public class Main {
    public static void main(String[] args) {
        Iterator<String> it = new Zoo();

        while (it.hasNext()) {
            System.out.println(it.next());
        }
    }
}

class Zoo implements Iterator<String> {
    String[] animals = { "Panda", "Rabbit" };
    int index = 0;

    public boolean hasNext() {
        return index < animals.length;
    }

    @Override
    public String next() {
        String animal = animals[index];
        index++;
        return animal;
    }
}
```

How to use iterable:
```java
import java.util.Iterator;

public class Main {
    public static void main(String[] args) {
        Zoo z = new Zoo();

        for (String animal : z) {
            System.out.println(animal);
        }
    }
}

class Zoo implements Iterable<String> {
    String[] animals = { "Panda", "Rabbit" };

    public Iterator<String> iterator() {
        return new ZooIterator();
    }

    class ZooIterator implements Iterator<String> {

        int index = 0;

        public boolean hasNext() {
            return index < animals.length;
        }

        @Override
        public String next() {
            String animal = animals[index];
            index++;
            return animal;
        }
    }
}
```

## Iterator design pattern

The purpose is to provide access to a collection of encapsulated object without exposing the underlying representation.

The best way to use Iterable is to return the Iterator implementation of the data structure (ex: ArrayList)

## Strategy design pattern

A design which allows switching algorithm.
An example of the strategy design pattern is `Collection.sort()` which allows the client to use a custom comparison algorithm.

### Dependency Injection

Strategy design pattern where the strategy is an interface which the client is responsible for implementing.

## Interface segragation principle

Client should not be forced to implement interfaces it does not need. An interface should only contain methods that are often used together.