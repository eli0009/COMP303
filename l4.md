# Types and Interfaces

## Polymorphism

Interface allows any objects with the required methods to use a piece of code. Implementing an interface makes the class a subtype of the interface.

The class Bird is a subtype of Fly:
```java
class Bird implements Fly {

}
```

Using interface enables polymorphism because now we can assign a reference to `Bird` to a `Fly` variable
```java
Fly fly = new Bird();
```

A practical example with arraylist and linkedlist. Both classes are implementation of the `List` interface.
```java
List<Integer> list = new ArrayList<>();
List<Integer> list = new LinkedList<>();
```

## Iterator and Iterable

As in [IterUse.java](code/IterUse.java) you need to implement `Iterable <T>` in your class which returns an interator. An iterator is an implementation of `Iterator<T>` (See inner class)

## ITERATOR design pattern

The purpose is to provide access to a collection of encapsulated object without exposing the underlying representation.

The best way to use Iterable is to return the Iterator implementation of the data structure (ex: ArrayList)

## STRATEGY design pattern

Goal: allow switching algorithm.

An example of the strategy design pattern is `Collection.sort()` which allows the client to use a custom comparison algorithm.

Ex: In [Strategy.java](code/Strategy.java) you can either sort the items by name or by price.

```java
class Item {
    private String name;
    private int price;

    public Item(String name, int price) {
        this.name = name;
        this.price = price;
    }

    public static Comparator<Item> createByNameComparator() {
        return new Comparator<Item>() {
            @Override
            public int compare(Item o1, Item o2) {
                return o1.getName().compareTo(o2.getName());
            }
        };
    }

    public static Comparator<Item> createByPriceComparator() {
        return new Comparator<Item>() {
            @Override
            public int compare(Item o1, Item o2) {
                return o1.getPrice() - o2.getPrice();
            }
        };
    }
    // omitted
}
```


### Dependency Injection

Strategy design pattern where the strategy is an interface which the client is responsible for implementing.

## Interface segragation principle

Client should not be forced to implement interfaces it does not need. An interface should only contain methods that are often used together.